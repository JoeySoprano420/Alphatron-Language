Hereâ€™s a greatly expanded version of the Standard Library for Alphatron by Draco 420, incorporating more diverse utilities, mathematical functions, and data structure methods to provide greater flexibility and depth:

@ StandardLibrary
<
    |*| string_utils
    <
        |*| to_upper
        <
            |*| input : string
            @ Return
            <
                |*| result : string => upper(input)
            >
        >
        |*| to_lower
        <
            |*| input : string
            @ Return
            <
                |*| result : string => lower(input)
            >
        >
        |*| capitalize
        <
            |*| input : string
            @ Return
            <
                |*| result : string => capitalize(input)
            >
        >
        |*| is_alpha
        <
            |*| input : string
            @ Return
            <
                |*| result : bool => is_alpha(input)
            >
        >
        |*| is_numeric
        <
            |*| input : string
            @ Return
            <
                |*| result : bool => is_numeric(input)
            >
        >
        |*| substring
        <
            |*| input : string
            |*| start : int
            |*| length : int
            @ Return
            <
                |*| result : string => substring(input, start, length)
            >
        >
        |*| replace
        <
            |*| input : string
            |*| old_str : string
            |*| new_str : string
            @ Return
            <
                |*| result : string => replace(input, old_str, new_str)
            >
        >
        |*| trim
        <
            |*| input : string
            @ Return
            <
                |*| result : string => trim(input)
            >
        >
        |*| starts_with
        <
            |*| input : string
            |*| prefix : string
            @ Return
            <
                |*| result : bool => starts_with(input, prefix)
            >
        >
        |*| ends_with
        <
            |*| input : string
            |*| suffix : string
            @ Return
            <
                |*| result : bool => ends_with(input, suffix)
            >
        >
        |*| split
        <
            |*| input : string
            |*| delimiter : string
            @ Return
            <
                |*| result : [string] => split(input, delimiter)
            >
        >
        |*| join
        <
            |*| elements : [string]
            |*| delimiter : string
            @ Return
            <
                |*| result : string => join(elements, delimiter)
            >
        >
        |*| contains
        <
            |*| input : string
            |*| substring : string
            @ Return
            <
                |*| result : bool => contains(input, substring)
            >
        >
    >
    
    |*| math_utils
    <
        |*| add
        <
            |*| a : int
            |*| b : int
            @ Return
            <
                |*| result : int => a + b
            >
        >
        |*| subtract
        <
            |*| a : int
            |*| b : int
            @ Return
            <
                |*| result : int => a - b
            >
        >
        |*| multiply
        <
            |*| a : int
            |*| b : int
            @ Return
            <
                |*| result : int => a * b
            >
        >
        |*| divide
        <
            |*| a : int
            |*| b : int
            @ Return
            <
                |*| result : float => float(a) / float(b)
            >
        >
        |*| power
        <
            |*| base : int
            |*| exponent : int
            @ Return
            <
                |*| result : int => pow(base, exponent)
            >
        >
        |*| sqrt
        <
            |*| num : int
            @ Return
            <
                |*| result : float => sqrt(num)
            >
        >
        |*| factorial
        <
            |*| num : int
            @ Return
            <
                |*| result : int => factorial(num)
            >
        >
        |*| log
        <
            |*| num : float
            |*| base : float
            @ Return
            <
                |*| result : float => log(num, base)
            >
        >
        |*| sin
        <
            |*| angle : float
            @ Return
            <
                |*| result : float => sin(angle)
            >
        >
        |*| cos
        <
            |*| angle : float
            @ Return
            <
                |*| result : float => cos(angle)
            >
        >
        |*| tan
        <
            |*| angle : float
            @ Return
            <
                |*| result : float => tan(angle)
            >
        >
        |*| round
        <
            |*| num : float
            |*| digits : int
            @ Return
            <
                |*| result : float => round(num, digits)
            >
        >
        |*| floor
        <
            |*| num : float
            @ Return
            <
                |*| result : float => floor(num)
            >
        >
        |*| ceil
        <
            |*| num : float
            @ Return
            <
                |*| result : float => ceil(num)
            >
        >
    >
    
    |*| data_structures
    <
        |*| list
        <
            |*| elements : [any]
            @ Add
            <
                |*| element : any
                |*| elements => append(elements, element)
            >
            @ Remove
            <
                |*| element : any
                |*| elements => remove(elements, element)
            >
            @ Find
            <
                |*| element : any
                @ Return
                <
                    |*| result : int => find(elements, element)
                >
            >
            @ Reverse
            <
                @ Return
                <
                    |*| result : [any] => reverse(elements)
                >
            >
        >
        |*| set
        <
            |*| elements : {any}
            @ Add
            <
                |*| element : any
                |*| elements => insert(elements, element)
            >
            @ Remove
            <
                |*| element : any
                |*| elements => remove(elements, element)
            >
            @ Union
            <
                |*| other_set : {any}
                @ Return
                <
                    |*| result : {any} => union(elements, other_set)
                >
            >
            @ Intersection
            <
                |*| other_set : {any}
                @ Return
                <
                    |*| result : {any} => intersection(elements, other_set)
                >
            >
            @ Difference
            <
                |*| other_set : {any}
                @ Return
                <
                    |*| result : {any} => difference(elements, other_set)
                >
            >
        >
        |*| map
        <
            |*| key_value_pairs : {any: any}
            @ Add
            <
                |*| key : any
                |*| value : any
                |*| key_value_pairs => set_item(key_value_pairs, key, value)
            >
            @ Remove
            <
                |*| key : any
                |*| key_value_pairs => delete_item(key_value_pairs, key)
            >
            @ Keys
            <
                @ Return
                <
                    |*| result : [any] => keys(key_value_pairs)
                >
            >
            @ Values
            <
                @ Return
                <
                    |*| result : [any] => values(key_value_pairs)
                >
            >
        >
        |*| stack
        <
            |*| elements : [any]
            @ Push
            <
                |*| element : any
                |*| elements => push(elements, element)
            >
            @ Pop
            <
                |*| elements => pop(elements)
            >
            @ Peek
            <
                @ Return
                <
                    |*| result : any => peek(elements)
                >
            >
        >
        |*| queue
        <
            |*| elements : [any]
            @ Enqueue
            <
                |*| element : any
                |*| elements => enqueue(elements, element)
            >
            @ Dequeue
            <
                |*| elements => dequeue(elements)
            >
            @ Peek
            <
                @ Return
                <
                    |*| result : any => peek(elements)
                >
            >
        >
    >
>

